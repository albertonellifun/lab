<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, height=device-height, maximum-scale=1.0">
<title>Sistema Solare</title>
<style>
body { margin:0; background:black; overflow:hidden; font-family: monospace; color: #fff; }
canvas { display:block; touch-action: none; }
#controls { position: absolute; top:0; left:0; overflow: hidden; z-index: 10; }
#info { position: absolute; bottom:0; left:0; color: #333; overflow: hidden; filter: opacity(0.9); }
p { margin: 0 0 0 10px; }
.planet { display: flex; justify-content: flex-start; align-items: center; white-space: nowrap; overflow: hidden; }
button { min-width: 30px; min-height: 30px; }
</style>
</head>
<body>
<div id="controls">
	<button onclick="TIME_STEP /= ts;document.getElementById('TS').innerHTML=TIME_STEP+'s'">-</button>
	TIMESTEP
	<button onclick="TIME_STEP *= ts;document.getElementById('TS').innerHTML=TIME_STEP+'s'">+</button>
	= <span id="TS">86400s</span>
	<br/>
	<button onclick="autocenter=!autocenter;document.getElementById('AC').innerHTML=autocenter">AUTOCENTER</button>
	= <span id="AC">true</span>
	<br/>
	<button onclick="zoom=1;document.getElementById('ZOOM').innerHTML=zoom">Z</button>MOUSE WHEEL = ZOOM = <span id="ZOOM">1</span>
	<br/>
	MOUSE CLICK = CENTER
	<br/>
	AUTOCENTER 0..9 / S=sun / C=center of mass
	<br/>
	MOUSE RIGHT CLICK = ADD SUN
	<br/>
	<button onclick="forcedCenterBody=null;autocenter=true;document.getElementById('AC').innerHTML=autocenter;">C</button>CENTER OF MASS = <span id="CENTEROFMASS"></span>
	<br/>
	<button onclick="paused=!paused;document.getElementById('PAUSED').innerHTML=paused">PAUSED</button>
	= <span id="PAUSED">false</span>
	<br/>
	<button onclick="BORDER=!BORDER;document.getElementById('BORDER').innerHTML=BORDER">BORDER</button>
	= <span id="BORDER">true</span>
	<br/>
	<button onclick="LABEL=!LABEL;document.getElementById('LABEL').innerHTML=LABEL">LABEL</button>
	= <span id="LABEL">true</span>
	<br/>
	<button onclick="PATH=!PATH;document.getElementById('PATH').innerHTML=PATH">PATH</button>
	= <span id="PATH">true</span>
	<br/>
	OBJECTS = <span id="OBJECTS"></span>
	<br/>
	PATH LEN = <span id="PATHLEN"></span>
	<br/>
	EXPLO COUNT = <span id="EXPLOCOUNT"></span>
	<br/>
	MERGE COUNT = <span id="MERGECOUNT"></span>
	<br/>
	<button onclick="draw3D=!draw3D;document.getElementById('DRAW3D').innerHTML=draw3D">DRAW 3D</button>
	= <span id="DRAW3D">false</span>
	<br/>
	<button onclick="if(document.getElementById('info').style.display=='none')document.getElementById('info').style.display='block';else document.getElementById('info').style.display='none';">INFO</button>
</div>
<div id="info" style="display:none"></div>

<canvas id="space"></canvas>

<script>

// ===== COSTANTI REALI =====
const G = 6.67430e-11;//costante gravitazione universale
const AU = 1.496e11;//unita astronomica
const DAY = 86400;//secondi
const SCALE = 90 / AU;
let zoom = 1;
let TIME_STEP = DAY * 1; //1 giorno per frame (limite stabilità con Mercurio)
let autocenter = true;//centra vista sul centro di massa CM calcolato ogni frame
let paused = false;//pausa on/off
let spd = 1.05;//speed +/-
let mass = 1.05;//mass +/-
let ts = 2;//time step +/-
let BORDER = true;
let LABEL = true;
let PATH = true;
let exploCount = 0;
let mergeCount = 0;
let nasaApiErrors = true;//se ci sono errori con api nasa -> pianeti ed asteroidi hanno solo X/Y, Z=0
let draw3D = false;//drawAllBodies / drawAllBodies3D

const canvas = document.getElementById("space");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let CENTER_X = canvas.width/2;
let CENTER_Y = canvas.height/2;

let forcedCenterBody = null; //corpo su cui centrare l'autocenter (== follow)

class Body {
    constructor(name, mass, x, y, z, vx, vy, vz, radius, color, realRadius){
        this.name = name;
        this.mass = mass;
        this.x = x;
        this.y = y;
		this.z = z;
        this.vx = vx;
        this.vy = vy;
		this.vz = vz;
        this.radius = radius;//px per render
		this.realRadius = realRadius;
        this.color = color;
		this.path = [{x:this.x, y:this.y, z:this.z}];//percorso=posizioni passate
		this.pathIndex = 0;
		this.ax = 0;//accelerazione corrente (x)
		this.ay = 0;//accelerazione corrente (y)
		this.az = 0;//accelerazione corrente (z)
    }

	updatePath() {
		const maxLen = Math.floor(50000 / bodies.length); // lunghezza massima path
		const thresholdDistance = 5e9; // 5 miliardi di metri (~0.033 AU)

		const lastIdx = this.path.length - 1;
		const lastPos = this.path[lastIdx];

		if(!lastPos){
			this.path.push({x:this.x, y:this.y, z:this.z});
			return;
		}

		// distanza reale tra il punto corrente e l'ultimo salvato
		const dx = this.x - lastPos.x;
		const dy = this.y - lastPos.y;
		const dz = this.z - lastPos.z;
		const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

		if(dist > thresholdDistance){
			const newPoint = {x:this.x, y:this.y, z:this.z};

			if(this.path.length >= maxLen){
				this.pathIndex = (this.pathIndex + 1) % maxLen;
				this.path[this.pathIndex] = newPoint;
			} else {
				this.path.push(newPoint);
			}
		}
	}



    draw(){
		const p = worldToCanvas(this.x, this.y);
		const px = p.x;
		const py = p.y;
		const zf = zoom / 50;
		const r = this.radius * zf;//

		// Disegno base pianeta
		ctx.beginPath();
		ctx.arc(px, py, r, 0, Math.PI*2);
		ctx.fillStyle = this.color;
		ctx.fill();

		if (this !== sun && this.name.indexOf("SUN") === -1) {
			// ===== DIREZIONE LUCE DAL SOLE =====
			const dx = sun.x - this.x;
			const dy = sun.y - this.y;
			const angle = Math.atan2(dy, dx);

			ctx.save();

			// Clip al cerchio del pianeta
			ctx.beginPath();
			ctx.arc(px, py, r, 0, Math.PI*2);
			ctx.clip();

			// Impostiamo modalità moltiplicazione (ombra realistica)
			ctx.globalCompositeOperation = "multiply";

			// Creiamo gradiente ombra
			const shadowGradient = ctx.createLinearGradient(
				px - Math.cos(angle) * r,
				py - Math.sin(angle) * r,
				px + Math.cos(angle) * r,
				py + Math.sin(angle) * r
			);

			shadowGradient.addColorStop(0, "rgba(0,0,0,1)");
			shadowGradient.addColorStop(0.5, "rgba(0,0,0,0.25)");
			shadowGradient.addColorStop(1, "rgba(0,0,0,0)");

			ctx.fillStyle = shadowGradient;
			ctx.fillRect(px - r, py - r, r*2, r*2);
			ctx.restore();
			
			//saturn ringsss
			if (this === saturn) {				
				ctx.beginPath();
				ctx.strokeStyle="rgba(200,180,120,0.25)";
				ctx.lineWidth = 5 * zf;
				ctx.ellipse(px, py, r*2.2, r*3.2, Math.PI/4, 0, Math.PI*2);
				ctx.stroke();
				ctx.lineWidth = 1;
			}			
		} else {
			ctx.shadowColor = this.color;
			ctx.shadowBlur = r * 3; // più grande = glow più ampio
			ctx.fill();
		}
		
		if(BORDER){
			ctx.strokeStyle = "#fff";
			ctx.stroke();
		}

		if(LABEL){
			ctx.fillStyle = "#fff";
			ctx.fillText(
				this.name,
				px + r * Math.sqrt(zoom) + 10,
				py - r * Math.sqrt(zoom) - 10
			);
		}
	}

	
	drawPath(){
		ctx.fillStyle = this.color;

		const len = this.path.length;
		const maxLen = Math.floor(50000 / bodies.length);

		// Se non abbiamo ancora raggiunto il maxLen, disegnamo normalmente
		if(len < maxLen){
			for(let i = 0; i < len; i++){
				const p = worldToCanvas(this.path[i].x, this.path[i].y);
				ctx.fillRect(p.x-0.5, p.y-0.5, 1, 1);
			}
		} else {
			// Disegno del buffer circolare
			for(let i = 0; i < len; i++){
				const idx = (this.pathIndex + 1 + i) % len; // parte dal punto più vecchio
				const p = worldToCanvas(this.path[idx].x, this.path[idx].y);
				ctx.fillRect(p.x-0.5, p.y-0.5, 1, 1);
			}
		}
	}


	computeAcceleration(bodies){
		let ax = 0;
		let ay = 0;
		let az = 0;

		for(let other of bodies){
			if(other === this) continue;

			const dx = other.x - this.x;
			const dy = other.y - this.y;
			const dz = other.z - this.z;
			
			const minDist = other.realRadius + this.realRadius;
			const distSq = Math.max(dx*dx + dy*dy + dz*dz, minDist*minDist);
			
			const invDist = 1 / Math.sqrt(distSq); // softening
			const invDist3 = invDist * invDist * invDist;
			
			ax += G * other.mass * dx * invDist3;
			ay += G * other.mass * dy * invDist3;
			az += G * other.mass * dz * invDist3;
		}

		return { ax, ay, az };
	}

}

// ===== CORPI =====
//name, mass, 
//x, y, z, 
//vx, vy, vz, 
//radius, color, realRadius

//sole circa 10 volte giove
//giove appena piu grande saturno
//giove 3 volte nettuno
//giove 11 volte la terra
//nettuno 4 volte la terra
//sole 400 volte la luna
// Sole
const sun = new Body("SUN", 1.989e30, 
0,0,0,
0,0,0,
50, "#ffffdd", 6.9634e8);
// Mercurio
const mercury = new Body("MERCURY", 3.301e23,
0.387 * AU, 0, 0,
0, 47870, 0,
5, "#cc9988", 2.4397e6);
// Venere
const venus = new Body("VENUS", 4.867e24,
0.723 * AU, 0, 0,
0, 35020, 0,
6, "#ddddaa", 6.0518e6);
// Terra
const earth = new Body("EARTH", 5.972e24, 
AU, 0, 0, 
0, 29780, 0,
7, "#4499ee", 6.371e6);
// Luna
const moon = new Body("MOON", 7.342e22, 
AU + 384400000, 0, 0,
0, 29780 + 1022, 0,
2, "#eeeeee", 1.7371e6);
// Marte
const mars = new Body("MARS", 6.39e23, 
1.524 * AU, 0, 0,
0, 24077, 0,
6, "#cc3322", 3.3895e6);
// Giove
const jupiter = new Body("JUPITER", 1.898e27, 
5.204 * AU, 0, 0,
0, 13070, 0,
10, "#cc9966", 6.9911e7);
// Saturno
const saturn = new Body("SATURN", 5.683e26, 
9.582 * AU, 0, 0,
0, 9680, 0,
9, "#eecc99", 5.8232e7);
// Urano
const uranus = new Body("URANUS", 8.681e25, 
19.191 * AU, 0, 0,
0, 6800, 0,
8, "#77ddff", 2.5362e7);
// Nettuno
const neptune = new Body("NEPTUNE", 1.024e26, 
30.07 * AU, 0, 0, 
0, 5400, 0,
7, "#4477dd", 2.4622e7);
// Plutone
const pluto = new Body("PLUTO", 1.309e22, 
39.48 * AU, 0, 0,
0, 4700, 0,
6, "#ddccaa", 1.1883e6);


const bodies = [ sun, mercury, venus, earth, moon, mars, jupiter, saturn, uranus, neptune, pluto ];

//ho invertito y perchè altrimenti rotazione oraria (sul sito nasa è antioraria)
//nel canvas, origine in alto a sinistra, y verso il basso, x verso destra
//nel sito nasa, origine è basso a sinitra, y verso alto, x verso destra (== SCUOLA)
function worldToCanvas(x, y) {
    return { x: CENTER_X + x * SCALE * zoom, y: CENTER_Y - y * SCALE * zoom };
}

function canvasToWorld(cx, cy){
    return { 
		x: (cx - CENTER_X) / (SCALE * zoom), 
		y: (CENTER_Y - cy) / (SCALE * zoom) //occhio, qui centery - cy perchè le coordinate mondo crescono verso alto, il canvas cresce verso il basso
	};
}


function animate(){
	ctx.clearRect(0,0,canvas.width,canvas.height);

	if (!paused){
		updateAllBodies();
	}
		
	drawCanvasCenter();
	
	checkCollisions();
	
	if(draw3D) drawAllBodies3D();
	else drawAllBodies();
	
	drawStats();
	
    requestAnimationFrame(animate);
}

function updateAllBodies() {
	// 1. Calcoliamo le accelerazioni ATTUALI (a_t) per tutti
	// Invece di sovrascrivere body.ax subito, usiamo una costante temporanea
    // o assicuriamoci che il calcolo sia atomico.
    let accelerations = bodies.map(body => body.computeAcceleration(bodies));

    // 2. Aggiorniamo le POSIZIONI di tutti
    for (let i = 0; i < bodies.length; i++) {
        let b = bodies[i];
        let a = accelerations[i];
        
		// x(t + dt) = x(t) + v(t)*dt + 0.5 * a(t) * dt^2
        b.x += b.vx * TIME_STEP + 0.5 * a.ax * TIME_STEP * TIME_STEP;
        b.y += b.vy * TIME_STEP + 0.5 * a.ay * TIME_STEP * TIME_STEP;
		b.z += b.vz * TIME_STEP + 0.5 * a.az * TIME_STEP * TIME_STEP;
		
		// Memorizziamo l'accelerazione vecchia per il calcolo della velocità dopo
		b.ax = a.ax;
		b.ay = a.ay;
		b.az = a.az;
	
		b.updatePath();
	}

    // 3. Aggiorniamo le VELOCITÀ di tutti
    for (let b of bodies) {
		// Calcoliamo la NUOVA accelerazione (a_t+dt) nella nuova posizione
		let newAcc = b.computeAcceleration(bodies);
		
		// v(t + dt) = v(t) + 0.5 * (a(t) + a(t + dt)) * dt
		b.vx += 0.5 * (b.ax + newAcc.ax) * TIME_STEP;
		b.vy += 0.5 * (b.ay + newAcc.ay) * TIME_STEP;
		b.vz += 0.5 * (b.az + newAcc.az) * TIME_STEP;
	}
}

function drawAllBodies() {
	for (let body of bodies) {
		if (PATH) body.drawPath();

		body.draw();
	}
}

//la croce, fixata 
function drawCanvasCenter() {
    if (!autocenter) return;

    let target = forcedCenterBody || computeCenterOfMass(bodies);
    const targetPos = worldToCanvas(target.x, target.y);//posizione canvas del target
    const dx = canvas.width / 2 - targetPos.x;
    const dy = canvas.height / 2 - targetPos.y;

    CENTER_X += dx;
    CENTER_Y += dy;

    // disegna croce al centro
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 0.2;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();

    ctx.fillText(
        forcedCenterBody ? 'CENTER OF '+forcedCenterBody.name : 'CENTER OF MASS',
        canvas.width / 2 - 50,
        10
    );
}


//zoom
canvas.addEventListener("wheel", (e) => {
    e.preventDefault();

    const zoomFactor = 1.1;
    const mouseX = e.clientX;
    const mouseY = e.clientY;

	// Convertiamo le coordinate del mouse in coordinate canvas attuali
	const mouseWorldPos = canvasToWorld(mouseX, mouseY);
    
    // Aggiorniamo lo zoom
    if (e.deltaY < 0) zoom *= zoomFactor;
    else zoom /= zoomFactor;

    // Calcoliamo la nuova posizione canvas dopo lo zoom
    const newCanvasPos = worldToCanvas(mouseWorldPos.x, mouseWorldPos.y);

    // Spostiamo CENTER_X/Y affinché il punto sotto il mouse resti fisso
    CENTER_X += mouseX - newCanvasPos.x;
    CENTER_Y += mouseY - newCanvasPos.y;

    document.getElementById("ZOOM").innerHTML = zoom;
});




//gestione click
canvas.addEventListener("click", (e) => {
    handleLeftClick(e);
});
function handleLeftClick(pointer) {
    const mouseX = pointer.clientX;
    const mouseY = pointer.clientY;

    // coordinate "mondo" del punto cliccato
	const mouseWorldPos = canvasToWorld(mouseX, mouseY);
    
    // posizione canvas corrente del punto cliccato
    const canvasPos = worldToCanvas(mouseWorldPos.x, mouseWorldPos.y);

    // aggiorniamo CENTER_X/Y affinché il punto cliccato vada al centro del canvas
    CENTER_X += canvas.width / 2 - canvasPos.x;
    CENTER_Y += canvas.height / 2 - canvasPos.y;
}



// Gestione tasti
window.addEventListener("keydown", (e) => {
    let index = -1;
    if (e.key >= "1" && e.key <= "9") index = parseInt(e.key);
    else if (e.key === "0") index = 10; // Plutone

    if (index >= 0 && index < bodies.length) {
        forcedCenterBody = bodies[index];
    }
    // tasto S per Sole
    if (e.key === "s" || e.key === "S") forcedCenterBody = bodies[0];
	if (e.key === "c" || e.key === "C") forcedCenterBody = null;
	if (e.key === "z" || e.key === "Z") zoom = 1;
});


//gestione click destro
canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    handleRightClick(e);
});
let newSunIdx = 0;
function handleRightClick(pointer) {

    const mouseX = pointer.clientX;
    const mouseY = pointer.clientY;

	// coordinate "mondo" del punto cliccato
	const mouseWorldPos = canvasToWorld(mouseX, mouseY);
	
	newSunIdx++;

    let mass = parseFloat(prompt("Insert SUN"+newSunIdx+" mass", sun.mass/4)) || sun.mass/4;
    let realRadius = parseFloat(prompt("Insert SUN"+newSunIdx+" radius", sun.realRadius/3)) || sun.realRadius/3;
    let speedX = parseFloat(prompt("Insert SUN"+newSunIdx+" vx", -5000)) || 0;
    let speedY = parseFloat(prompt("Insert SUN"+newSunIdx+" vy", 5000)) || 0;
	let speedZ = parseFloat(prompt("Insert SUN"+newSunIdx+" vz", 0)) || 0;
	let posZ = parseFloat(prompt("Insert SUN"+newSunIdx+" z", 0)) || 0;
    let radius = parseFloat(prompt("Insert SUN"+newSunIdx+" draw radius", 10)) || 10;

    const sun2 = new Body(
        "SUN"+newSunIdx,
        mass,
        mouseWorldPos.x,
        mouseWorldPos.y,
		posZ,
        speedX,		// velocità iniziale x
        speedY,		// velocità iniziale x
		speedZ,		// velocità iniziale z
        radius,		// raggio render più piccolo
        "#ffff99",	// colore leggermente diverso
        realRadius	//raggio
    );

    const acc = sun2.computeAcceleration(bodies);
    sun2.ax = acc.ax;
    sun2.ay = acc.ay;
	sun2.az = acc.az;

    bodies.push(sun2);
}


//gestione zoom mobile
let initialDistance = null;
let initialZoom = null;
canvas.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2) {
        e.preventDefault();

        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx*dx + dy*dy);

        if (!initialDistance) {
            initialDistance = distance;
            initialZoom = zoom;
        } else {
            zoom = initialZoom * (distance / initialDistance);
            document.getElementById("ZOOM").innerHTML = zoom;
        }
    }
}, { passive: false });
canvas.addEventListener("touchend", () => {
    initialDistance = null;
});

//fix cm
function fixCenterOfMass(bodies){
    let totalMass = 0;
    let px = 0;
    let py = 0;
	let pz = 0;

    for (let b of bodies){
        totalMass += b.mass;
        px += b.mass * b.vx;
        py += b.mass * b.vy;
		pz += b.mass * b.vz;
    }

    const vxCM = px / totalMass;
    const vyCM = py / totalMass;
	const vzCM = pz / totalMass;

    for (let b of bodies){
        b.vx -= vxCM;
        b.vy -= vyCM;
		b.vz -= vzCM;
    }
}

//calcolo cm
function computeCenterOfMass(bodies){
    let totalMass = 0;
    let x = 0;
    let y = 0;
	let z = 0;

    for (let b of bodies){
        totalMass += b.mass;
        x += b.mass * b.x;
        y += b.mass * b.y;
		z += b.mass * b.z;
    }

    return {
        x: x / totalMass,
        y: y / totalMass,
		z: z / totalMass
    };
}

//mostro i dati in formato esponenziale con un paio di decimali
function drawStats() {
	bodies.forEach(item => { 
		let exists = document.getElementById(item.name) != null;
		if(exists) {
			document.getElementById(item.name).innerHTML = 
			'<span style="color: '+item.color+'">' + item.name + '</span>:' +
			' mass=' + (item.mass.toExponential(2)) + 'kg ' +
			' radius=' + (item.realRadius.toExponential(2)) + 'm ' +
			' x=' + (item.x.toExponential(2)) + 'm ' +
			' y=' + (item.y.toExponential(2)) + 'm ' +
			' z=' + (item.z.toExponential(2)) + 'm ' +
			' vx=' + (item.vx.toExponential(2)) + 'm/s ' +
			' vy=' + (item.vy.toExponential(2)) + 'm/s ' + 
			' vz=' + (item.vz.toExponential(2)) + 'm/s '
		}
	});
	document.getElementById("OBJECTS").innerHTML = bodies.length;
	document.getElementById("PATHLEN").innerHTML = bodies.length > 2 ? bodies[1].path.length : bodies[0].path.length;
	document.getElementById("EXPLOCOUNT").innerHTML = exploCount;
	document.getElementById("MERGECOUNT").innerHTML = mergeCount;
	
	const cm = computeCenterOfMass(bodies);
	document.getElementById("CENTEROFMASS").innerHTML = "x=" + (cm.x.toExponential(2)) + "m y=" + (cm.y.toExponential(2))+"m z=" + (cm.z.toExponential(2))+"m";
}

//GESTIONE COLLISIONI
function checkCollisions() {
    for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {

            const b1 = bodies[i];
            const b2 = bodies[j];

            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
			const dz = b2.z - b1.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            const collisionDistance = b1.realRadius + b2.realRadius;

			if (dist < collisionDistance * 32 && TIME_STEP > 5400) {
				TIME_STEP /= 2;
				document.getElementById('TS').innerHTML=TIME_STEP;
			}
				
			if (dist <= collisionDistance * 4) {
				resolveImpact(b1, b2, dist, dx, dy, dz);
                return;
            }
        }
    }
}

//impatto fonde o frantuma?
function resolveImpact(b1, b2, dist, dx, dy, dz) {

    const dvx = b1.vx - b2.vx;//delta velocita x
    const dvy = b1.vy - b2.vy;//delta velocita y
	const dvz = b1.vz - b2.vz;//delta velocita z

    const reducedMass = (b1.mass * b2.mass) / (b1.mass + b2.mass);
    const relativeSpeedSq = dvx*dvx + dvy*dvy + dvz*dvz;

    const kineticEnergy = 0.5 * reducedMass * relativeSpeedSq;//1/2mv2

    const gravitationalBinding = G * b1.mass * b2.mass / (b1.realRadius + b2.realRadius);

    if (kineticEnergy > gravitationalBinding) {
        fragmentBodies(b1, b2);
		exploCount++;
		rebuildInfoPanel();
    } else {
        mergeBodies(b1, b2);
		mergeCount++;
		rebuildInfoPanel();
    }
}

//fusione tra 2 corpi
function mergeBodies(b1, b2){

    const newMass = b1.mass + b2.mass;

    const newVx = (b1.mass*b1.vx + b2.mass*b2.vx) / newMass;
    const newVy = (b1.mass*b1.vy + b2.mass*b2.vy) / newMass;
	const newVz = (b1.mass*b1.vz + b2.mass*b2.vz) / newMass;

    const newX = (b1.mass*b1.x + b2.mass*b2.x) / newMass;
    const newY = (b1.mass*b1.y + b2.mass*b2.y) / newMass;
	const newZ = (b1.mass*b1.z + b2.mass*b2.z) / newMass;

    const newRealRadius = Math.cbrt(
        Math.pow(b1.realRadius,3) +
        Math.pow(b2.realRadius,3)
    );

    const merged = new Body(
        b1.name + "+" + b2.name,
        newMass,
        newX,
        newY,
		newZ,
        newVx,
        newVy,
		newVz,
        Math.cbrt(b1.radius**3 + b2.radius**3),
        "#ffff55",
        newRealRadius
    );

    bodies.splice(bodies.indexOf(b1),1);
    bodies.splice(bodies.indexOf(b2),1);
    bodies.push(merged);
	forcedCenterBody = merged;
}

//frantumazione tra 2 corpi
function fragmentBodies(b1, b2){
    const fragments = 100;
    const totalMass = b1.mass + b2.mass;

    // Velocità e quantità di moto centro di massa
    const px = b1.mass*b1.vx + b2.mass*b2.vx;
    const py = b1.mass*b1.vy + b2.mass*b2.vy;
	const pz = b1.mass*b1.vz + b2.mass*b2.vz;
    const vcmX = px / totalMass;
    const vcmY = py / totalMass;
	const vcmZ = pz / totalMass;

    // Posizione centro di massa
    const centerX = (b1.mass*b1.x + b2.mass*b2.x) / totalMass;
    const centerY = (b1.mass*b1.y + b2.mass*b2.y) / totalMass;
	const centerZ = (b1.mass*b1.z + b2.mass*b2.z) / totalMass;

    // Energia cinetica totale dei due corpi
    const kineticBefore = 0.5 * b1.mass * (b1.vx**2 + b1.vy**2 + b1.vz**2) +
                          0.5 * b2.mass * (b2.vx**2 + b2.vy**2 + b2.vz**2);

    // Percentuale di energia da distribuire ai frammenti
    const explosionEnergyFraction = 0.01; // 10% dell'energia totale viene ai frammenti
    const energyForFragments = kineticBefore * explosionEnergyFraction;

    const massPerFragment = totalMass / fragments;

    // Energia per frammento
    const energyPerFragment = energyForFragments / fragments;
	const speed = Math.sqrt(2 * energyPerFragment / massPerFragment);//energy per ogni fragment, non energy for fragments!
	
    for (let i = 0; i < fragments; i++) {

        const angleXY = Math.random() * 2 * Math.PI;//xy
		const angleZ = nasaApiErrors ? (Math.PI / 2) : Math.acos(2 * Math.random() - 1);//z

        const vx = vcmX + speed * Math.sin(angleZ) * Math.cos(angleXY);
        const vy = vcmY + speed * Math.sin(angleZ) * Math.sin(angleXY);
        const vz = nasaApiErrors ? 0 : vcmZ + speed * Math.cos(angleZ);//cos(90) puo essere non esattamente zero
		
        const frag = new Body(
            "FRAG",
            massPerFragment,
            centerX,
            centerY,
			centerZ,
            vx,
            vy,
			vz,
            2,
            "#ffaa00",
            1e6
        );

        bodies.push(frag);
    }

    // Rimuovi corpi originali
    bodies.splice(bodies.indexOf(b1),1);
    bodies.splice(bodies.indexOf(b2),1);
}

//crea cintura di asteroidi (Z=0 se nasa ko)
function createOuterAsteroidBelt(count = 100, innerAU = 40, outerAU = 55){
    for(let i = 0; i < count; i++){
        const r = (innerAU + Math.random()*(outerAU-innerAU)) * AU;
        const angle = Math.random() * 2*Math.PI;

        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        const z = nasaApiErrors ? 0 : (Math.random() - 0.5) * 0.1 * AU;//piccolo offset verticale, zero se sto in orbita simulata (solo XY)

        //velocità orbitale circolare
        const v = Math.sqrt(G * sun.mass / r);

        // direzione tangenziale
        const vx = -v * Math.sin(angle);
        const vy =  v * Math.cos(angle);
        const vz = 0; //movimento principale nel piano XY

        const asteroid = new Body(
            "AST" + i,
            1e18,
            x, y, z,
            vx, vy, vz,
            1.5,
            "#888888",
            5e5
        );

        bodies.push(asteroid);
    }
}

//ui
function rebuildInfoPanel() {
    const info = document.getElementById("info");
    info.innerHTML = "";

    const maxItems = Math.min(11, bodies.length);
	let done = 0;
    for (let i = 0; i < bodies.length && done < maxItems; i++) {
		const body = bodies[i];
		if (body.name.indexOf("AST") === 0 || body.name.indexOf("FRAG") === 0) continue;
		done++;
		
		const wrapper = document.createElement("div");
        wrapper.className = "planet";

        // MASS LABEL
        const massLabel = document.createElement("p");
        massLabel.textContent = "MASS:";

        const massMinus = document.createElement("button");
        massMinus.textContent = "-";
        massMinus.onclick = () => body.mass /= mass;

        const massPlus = document.createElement("button");
        massPlus.textContent = "+";
        massPlus.onclick = () => body.mass *= mass;

        // SPEED LABEL
        const speedLabel = document.createElement("p");
        speedLabel.textContent = "SPEED:";

        const speedMinus = document.createElement("button");
        speedMinus.textContent = "-";
        speedMinus.onclick = () => {
            body.vx /= spd;
            body.vy /= spd;
        };

        const speedPlus = document.createElement("button");
        speedPlus.textContent = "+";
        speedPlus.onclick = () => {
            body.vx *= spd;
            body.vy *= spd;
        };

        const speedInvert = document.createElement("button");
        speedInvert.textContent = "INV";
        speedInvert.onclick = () => {
            body.vx *= -1;
            body.vy *= -1;
        };

        //INFO TEXT
        const infoText = document.createElement("p");
        infoText.id = body.name;
		
		//CENTER VIEW
		const centerButton = document.createElement("button");
		centerButton.textContent = "C";
		centerButton.onclick = () => { forcedCenterBody = body; autocenter = true; document.getElementById('AC').innerHTML = autocenter; };
		
		wrapper.appendChild(centerButton);
        wrapper.appendChild(massLabel);
        wrapper.appendChild(massMinus);
        wrapper.appendChild(massPlus);
        wrapper.appendChild(speedLabel);
        wrapper.appendChild(speedMinus);
        wrapper.appendChild(speedPlus);
        wrapper.appendChild(speedInvert);
        wrapper.appendChild(infoText);

        info.appendChild(wrapper);
    }
}


//DIO BENEDICA CHATGPT
async function initSolarSystemFromNASA() {
    const ids = {
        sun: '10',
        mercury: '199',
        venus: '299',
        earth: '399',
        moon: '301',
        mars: '499',
        jupiter: '599',
        saturn: '699',
        uranus: '799',
        neptune: '899',
        pluto: '999'
    };

    const bodiesMap = { sun, mercury, venus, earth, moon, mars, jupiter, saturn, uranus, neptune, pluto };
    const today = new Date().toISOString().split("T")[0];
    const tomorrow = new Date(Date.now() + 86400000).toISOString().split("T")[0];

    async function fetchWithTimeout(url, timeout = 8000) {
        return Promise.race([
            fetch(url),
            new Promise((_, reject) =>
                setTimeout(() => reject(new Error("Timeout NASA API")), timeout)
            )
        ]);
    }

    async function fetchBody(body, id) {
        const url =
`https://ssd.jpl.nasa.gov/api/horizons.api?format=json
&COMMAND='${id}'
&OBJ_DATA='NO'
&MAKE_EPHEM='YES'
&EPHEM_TYPE='VECTORS'
&CENTER='500@10'
&START_TIME='${today}'
&STOP_TIME='${tomorrow}'
&STEP_SIZE='1 d'`.replace(/\n/g,'');

        try {
            const res = await fetchWithTimeout(url);
            const json = await res.json();
            if (!json.result) throw new Error("Risposta NASA non valida");

            const lines = json.result.split("\n");
			const KM = 1000;
			
			//parse x,y,z
            const vectorLinePos = lines.find(l => l.includes("X ="));//spazio dopo 
            if (!vectorLinePos) throw new Error("Dati vettoriali (posizione x,y,z) non trovati");
            const valuesPos = vectorLinePos.match(/-?\d+\.\d+E[+-]\d+/g);
            
			let tmp = parseFloat(valuesPos[0]) * KM;
			if (isFinite(tmp)) body.x = tmp;
			
			tmp = parseFloat(valuesPos[1]) * KM;
			if (isFinite(tmp)) body.y = tmp;
			
			tmp = parseFloat(valuesPos[2]) * KM;
			if (isFinite(tmp)) body.z = tmp;
			
			//parse vx,vy,vz
			const vectorLineVel = lines.find(l => l.includes("VX="));//tutto attaccato!
            if (!vectorLineVel) throw new Error("Dati vettoriali (velocita vx,vy,vz) non trovati");

            const valuesVel = vectorLineVel.match(/-?\d+\.\d+E[+-]\d+/g);
			
			tmp = parseFloat(valuesVel[0]) * KM;
			if (isFinite(tmp)) body.vx = tmp;
			
			tmp = parseFloat(valuesVel[1]) * KM;
			if (isFinite(tmp)) body.vy = tmp;
			
			tmp = parseFloat(valuesVel[2]) * KM;
            if (isFinite(tmp)) body.vz = tmp;

            console.log(body.name + " inizializzato con successo");
			body.status = 'ok'
        } catch (err) {
            console.warn(`Errore init ${body.name}:`, err);
			body.status = 'ko';
			nasaApiErrors = true;
        }
    }

    document.body.style.cursor = "wait";

    for (let key of Object.keys(bodiesMap)) {
        await fetchBody(bodiesMap[key], ids[key]);
    }

    document.body.style.cursor = "default";
	let errors = '';
	bodies.forEach(item => { if(item.status==='ko') errors += item.name +' ';});
    alert("Sistema solare inizializzato con i dati NASA" + (errors ? ' (in errore: '+errors+')' : ''));
	if (!errors && !nasaApiErrors) {
		TIME_STEP = 1;//simulazione real time
		document.getElementById("TS").innerHTML=TIME_STEP+"s";
	}
}





// Parametri globali per la proiezione
const CAMERA_Z = 60 * AU;  // distanza della camera lungo Z
let camAlpha = Math.PI / 3; // rotazione verticale, 60°
let camBeta  = 0; // rotazione orizzontale 0°

function rotate3D(x, y, z) {
    // Rotazione attorno Y (orizzontale)
    let xr = x * Math.cos(camBeta) + z * Math.sin(camBeta);
    let zr = -x * Math.sin(camBeta) + z * Math.cos(camBeta);

    // Rotazione attorno X (verticale)
    let yr = y * Math.cos(camAlpha) - zr * Math.sin(camAlpha);
    let zr2 = y * Math.sin(camAlpha) + zr * Math.cos(camAlpha);

    return { x: xr, y: yr, z: zr2 };
}

function project3D(x, y, z) {
    const rotated = rotate3D(x, y, z);
    const safeZ = Math.min(rotated.z, CAMERA_Z - 0.1); // evita divisione negativa
    const scale = CAMERA_Z / (CAMERA_Z - safeZ);
    const px = CENTER_X + rotated.x * SCALE * zoom * scale;
    const py = CENTER_Y - rotated.y * SCALE * zoom * scale;//occhio, qui centery - ry perchè le coordinate mondo crescono verso alto, il canvas cresce verso il basso
    const rScale = scale;
    return { px, py, rScale, depth: rotated.z };
}

Body.prototype.draw3D = function() {
    const { px, py, rScale, depth } = project3D(this.x, this.y, this.z);
	
	ctx.beginPath();
    ctx.arc(px, py, Math.abs(this.radius * rScale / 10), 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();

    if(BORDER){
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 0.5 * rScale;
        ctx.stroke();
    }

    if(LABEL){
        ctx.fillStyle = "#fff";
        ctx.font = `${10 * rScale}px sans-serif`;
        ctx.fillText(this.name, px + 5, py - 5);
		ctx.font = "10px sans-serif";
    }
}

function drawAllBodies3D() {
    // calcola profondità e ordina dal più lontano al più vicino
    const sortedBodies = bodies.slice().sort((a, b) => {
        const aDepth = project3D(a.x, a.y, a.z).depth;
        const bDepth = project3D(b.x, b.y, b.z).depth;
        return aDepth - bDepth; // disegna prima quelli lontani
    });

    for (let body of sortedBodies) {
        body.draw3D();
    }
}






initSolarSystemFromNASA()
    .catch(() => {})

    .finally(() => {
		createOuterAsteroidBelt(100, 40, 55);//100 asteroidi tra 40->55 AU
		rebuildInfoPanel();

        fixCenterOfMass(bodies);
        animate();
});

</script>
</body>
</html>
