<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Sistema Solare</title>
<style>
body { margin:0; background:black; overflow:hidden; font-family: monospace; color: #fff; }
canvas { display:block; }
#controls { position: absolute; top:0; left:0; }
#info { position: absolute; bottom:0; left:0; color: #333; }
p { margin: 0 0 0 10px; }
.planet { display: flex; justify-content: flex-start; align-items: center; }
</style>
</head>
<body>
<div id="controls">
	<button onclick="TIME_STEP /= ts;document.getElementById('TS').innerHTML=TIME_STEP">-</button>
	TIMESTEP
	<button onclick="TIME_STEP *= ts;document.getElementById('TS').innerHTML=TIME_STEP">+</button>
	= <span id="TS">86400</span>
	<br/>
	<button onclick="autocenter=!autocenter;document.getElementById('AC').innerHTML=autocenter">AUTOCENTER</button>
	= <span id="AC">true</span>
	<br/>
	MOUSE WHEEL = ZOOM = <span id="ZOOM">1</span>
	<br/>
	MOUSE CLICK = CENTER
	<br/>
	AUTOCENTER 0..9 / S
	<br/>
	<button onclick="paused=!paused;document.getElementById('PAUSED').innerHTML=paused">PAUSED</button>
	= <span id="PAUSED">false</span>
	<br/>
	<button onclick="BORDER=!BORDER;document.getElementById('BORDER').innerHTML=BORDER">BORDER</button>
	= <span id="BORDER">true</span>
	<br/>
	<button onclick="LABEL=!LABEL;document.getElementById('LABEL').innerHTML=LABEL">LABEL</button>
	= <span id="LABEL">true</span>
	<br/>
	<button onclick="PATH=!PATH;document.getElementById('PATH').innerHTML=PATH">PATH</button>
	= <span id="PATH">true</span>
	<br/>
	OBJECTS = <span id="OBJECTS"></span>
	<br/>
	PATH LEN = <span id="PATHLEN"></span>
	<br/>
	<button onclick="if(document.getElementById('info').style.display=='none')document.getElementById('info').style.display='block';else document.getElementById('info').style.display='none';">INFO</button>
</div>
<div id="info">
	<div class="planet">
		<p>MASS:</p>
		<button onclick="sun.mass/=mass">-</button>
		<button onclick="sun.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="sun.vx/=spd;sun.vy/=spd">-</button>
		<button onclick="sun.vx*=spd;sun.vy*=spd">+</button>
		<button onclick="sun.vx*=-1;sun.vy*=-1">INV</button>
		<p id="SUN">SUN</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="mercury.mass/=mass">-</button>
		<button onclick="mercury.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="mercury.vx/=spd;mercury.vy/=spd">-</button>
		<button onclick="mercury.vx*=spd;mercury.vy*=spd">+</button>
		<button onclick="mercury.vx*=-1;mercury.vy*=-1">INV</button>
		<p id="MERCURY">MERCURY</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="venus.mass/=mass">-</button>
		<button onclick="venus.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="venus.vx/=spd;venus.vy/=spd">-</button>
		<button onclick="venus.vx*=spd;venus.vy*=spd">+</button>
		<button onclick="venus.vx*=-1;venus.vy*=-1">INV</button>
		<p id="VENUS">VENUS</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="earth.mass/=mass">-</button>
		<button onclick="earth.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="earth.vx/=spd;earth.vy/=spd">-</button>
		<button onclick="earth.vx*=spd;earth.vy*=spd">+</button>
		<button onclick="earth.vx*=-1;earth.vy*=-1">INV</button>
		<p id="EARTH">EARTH</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="moon.mass/=mass">-</button>
		<button onclick="moon.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="moon.vx/=spd;moon.vy/=spd">-</button>
		<button onclick="moon.vx*=spd;moon.vy*=spd">+</button>
		<button onclick="moon.vx*=-1;moon.vy*=-1">INV</button>
		<p id="MOON">MOON</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="mars.mass/=mass">-</button>
		<button onclick="mars.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="mars.vx/=spd;mars.vy/=spd">-</button>
		<button onclick="mars.vx*=spd;mars.vy*=spd">+</button>
		<button onclick="mars.vx*=-1;mars.vy*=-1">INV</button>
		<p id="MARS">MARS</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="jupiter.mass/=mass">-</button>
		<button onclick="jupiter.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="jupiter.vx/=spd;jupiter.vy/=spd">-</button>
		<button onclick="jupiter.vx*=spd;jupiter.vy*=spd">+</button>
		<button onclick="jupiter.vx*=-1;jupiter.vy*=-1">INV</button>
		<p id="JUPITER">JUPITER</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="saturn.mass/=mass">-</button>
		<button onclick="saturn.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="saturn.vx/=spd;saturn.vy/=spd">-</button>
		<button onclick="saturn.vx*=spd;saturn.vy*=spd">+</button>
		<button onclick="saturn.vx*=-1;saturn.vy*=-1">INV</button>
		<p id="SATURN">SATURN</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="uranus.mass/=mass">-</button>
		<button onclick="uranus.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="uranus.vx/=spd;uranus.vy/=spd">-</button>
		<button onclick="uranus.vx*=spd;uranus.vy*=spd">+</button>
		<button onclick="uranus.vx*=-1;uranus.vy*=-1">INV</button>
		<p id="URANUS">URANUS</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="neptune.mass/=mass">-</button>
		<button onclick="neptune.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="neptune.vx/=spd;neptune.vy/=spd">-</button>
		<button onclick="neptune.vx*=spd;neptune.vy*=spd">+</button>
		<button onclick="neptune.vx*=-1;neptune.vy*=-1">INV</button>
		<p id="NEPTUNE">NEPTUNE</p>
	</div>
	<div class="planet">
		<p>MASS:</p>
		<button onclick="pluto.mass/=mass">-</button>
		<button onclick="pluto.mass*=mass">+</button>
		<p>SPEED:</p>
		<button onclick="pluto.vx/=spd;pluto.vy/=spd">-</button>
		<button onclick="pluto.vx*=spd;pluto.vy*=spd">+</button>
		<button onclick="pluto.vx*=-1;pluto.vy*=-1">INV</button>
		<p id="PLUTO">PLUTO</p>
	</div>
</div>

<canvas id="space"></canvas>

<script>

// ===== COSTANTI REALI =====
const G = 6.67430e-11;//costante gravitazione universale
const AU = 1.496e11;//unita astronomica
const DAY = 86400;//secondi
const SCALE = 90 / AU;
let zoom = 1;
let TIME_STEP = DAY * 1; //1 giorno per frame (più stabile con Mercurio)
let autocenter = true;//centra vista sul centro di massa CM calcolato ogni frame
let paused = false;//pausa on/off
let spd = 1.05;//speed +/-
let mass = 1.05;//mass +/-
let ts = 2;//time step +/-
let BORDER = true;
let LABEL = true;
let PATH = true;

const canvas = document.getElementById("space");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let CENTER_X = canvas.width/2;
let CENTER_Y = canvas.height/2;

class Body {
    constructor(name, mass, x, y, vx, vy, radius, color, realRadius){
        this.name = name;
        this.mass = mass;
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = radius;//px per render
		this.realRadius = realRadius;
        this.color = color;
		this.path = [];//percorso=posizioni passate
		this.pathIndex = 0;
		this.ax = 0;//accelerazione corrente (x)
		this.ay = 0;//accelerazione corrente (y)
    }

    updateForces(bodies){
        let ax = 0;
        let ay = 0;

        for(let other of bodies){
            if(other === this) continue;

            const dx = other.x - this.x;
            const dy = other.y - this.y;
            const distSq = dx*dx + dy*dy;
            const dist = Math.sqrt(distSq);

            const a = G * other.mass / distSq;

            ax += a * dx / dist;
            ay += a * dy / dist;
        }

        this.vx += ax * TIME_STEP;
        this.vy += ay * TIME_STEP;
    }

    updatePosition() {
		this.x += this.vx * TIME_STEP;
		this.y += this.vy * TIME_STEP;
	}
	
	updatePath() {
		const lastIdx = this.path.length - 1;
		const lastPos = lastIdx === -1 ? {x: 0, y: 0} : this.path[lastIdx];

		//angolo attuale rispetto al sole
		const angle = Math.atan2(this.y, this.x);//this.y - sun.y, this.x - sun.x);//voglio vedere oscillazioni del sole!!!
		const lastAngle = Math.atan2(lastPos.y, lastPos.x);

		let deltaAngle = Math.abs(angle - lastAngle);
		deltaAngle = deltaAngle % (2*Math.PI);
		if (deltaAngle > Math.PI) deltaAngle = 2*Math.PI - deltaAngle;

		const threshold = Math.PI / 180 * 5; //5 gradi in radianti
		const maxLen = Math.floor(50000 / bodies.length);//5000 per pianeta circa
		
		if (deltaAngle > threshold) {
			if(this.path.length >= maxLen) {
				this.path[this.pathIndex] = {x:this.x, y:this.y};
				this.pathIndex = (this.pathIndex + 1) % maxLen;
			} else {
				this.path.push({x:this.x, y:this.y});
			}
		}
	}

    draw(){
		const px = CENTER_X + this.x * SCALE * zoom;
		const py = CENTER_Y + this.y * SCALE * zoom;
		const r = this.radius * zoom / 10;//

		// Disegno base pianeta
		ctx.beginPath();
		ctx.arc(px, py, r, 0, Math.PI*2);
		ctx.fillStyle = this.color;
		ctx.fill();

		if (this !== sun && this.name.indexOf("SUN") === -1) {
			// ===== DIREZIONE LUCE DAL SOLE =====
			const dx = sun.x - this.x;
			const dy = sun.y - this.y;
			const angle = Math.atan2(dy, dx);

			ctx.save();

			// Clip al cerchio del pianeta
			ctx.beginPath();
			ctx.arc(px, py, r, 0, Math.PI*2);
			ctx.clip();

			// Impostiamo modalità moltiplicazione (ombra realistica)
			ctx.globalCompositeOperation = "multiply";

			// Creiamo gradiente ombra
			const shadowGradient = ctx.createLinearGradient(
				px - Math.cos(angle) * r,
				py - Math.sin(angle) * r,
				px + Math.cos(angle) * r,
				py + Math.sin(angle) * r
			);

			shadowGradient.addColorStop(0, "rgba(0,0,0,1)");
			shadowGradient.addColorStop(0.5, "rgba(0,0,0,0.25)");
			shadowGradient.addColorStop(1, "rgba(0,0,0,0)");

			ctx.fillStyle = shadowGradient;
			ctx.fillRect(px - r, py - r, r*2, r*2);
			ctx.restore();
			
			//saturn ringsss
			if (this === saturn) {				
				ctx.beginPath();
				ctx.strokeStyle="rgba(200,180,120,0.25)";
				ctx.lineWidth = 5 * zoom / 10;
				ctx.ellipse(px, py, r*2.2, r*3.2, Math.PI/4, 0, Math.PI*2);
				ctx.stroke();
				ctx.lineWidth = 1;
			}			
		} else {
			ctx.shadowColor = this.color;
			ctx.shadowBlur = r * 3; // più grande = glow più ampio
			ctx.fill();
		}
		
		if(BORDER){
			ctx.strokeStyle = "#fff";
			ctx.stroke();
		}

		if(LABEL){
			ctx.fillStyle = "#fff";
			ctx.fillText(
				this.name,
				px + r * Math.sqrt(zoom) + 10,
				py - r * Math.sqrt(zoom) - 10
			);
		}
	}

	
	drawPath(){
		if(this.path.length < 1) return;

		ctx.fillStyle = this.color;
		
		for(let i = 0; i < this.path.length; i++){
			const px = CENTER_X + this.path[i].x * SCALE * zoom;
			const py = CENTER_Y + this.path[i].y * SCALE * zoom;
			ctx.fillRect(px-0.5, py-0.5, 1, 1);
		}
	}

	computeAcceleration(bodies){
		let ax = 0;
		let ay = 0;

		for(let other of bodies){
			if(other === this) continue;

			const dx = other.x - this.x;
			const dy = other.y - this.y;
			//const distSq = dx*dx + dy*dy + 1e6;//evita divisione per zero, numero epsilon vicino alle dimensioni dei corpi
			const minDist = other.realRadius + this.realRadius;
			const distSq = Math.max(dx*dx + dy*dy, minDist*minDist);
			/*
			const dist = Math.sqrt(distSq);
			const a = G * other.mass / distSq;
			ax += a * dx / dist;
			ay += a * dy / dist;
			*/
			const invDist = 1 / Math.sqrt(distSq); // softening
			const invDist3 = invDist * invDist * invDist;
			ax += G * other.mass * dx * invDist3;
			ay += G * other.mass * dy * invDist3;
		}

		return { ax, ay };
	}

}

// ===== CORPI =====
//name, mass, x, y, vx, vy, radius, color, realRadius
// Sole
const sun = new Body("SUN", 1.989e30, 0,0, 0,0, 20, "#ffffdd", 6.9634e8);
// Mercurio
const mercury = new Body("MERCURY", 3.301e23, 0.387 * AU, 0, 0, 47870, 4, "#cc9988", 2.4397e6);
// Venere
const venus = new Body("VENUS", 4.867e24, 0.723 * AU, 0, 0, 35020, 5, "#ddddaa", 6.0518e6);
// Terra
const earth = new Body("EARTH", 5.972e24, AU, 0, 0, 29780, 6, "#4499ee", 6.371e6);
// Luna
const moon = new Body("MOON", 7.342e22, AU + 384400000, 0, 0, 29780 + 1022, 2, "#eeeeee", 1.7371e6);
// Marte
const mars = new Body("MARS", 6.39e23, 1.524 * AU, 0, 0, 24077, 4, "#cc3322", 3.3895e6);
// Giove
const jupiter = new Body("JUPITER", 1.898e27, 5.204 * AU, 0, 0, 13070, 10, "#cc9966", 6.9911e7);
// Saturno
const saturn = new Body("SATURN", 5.683e26, 9.582 * AU, 0, 0, 9680, 9, "#eecc99", 5.8232e7);
// Urano
const uranus = new Body("URANUS", 8.681e25, 19.191 * AU, 0, 0, 6800, 8, "#77ddff", 2.5362e7);
// Nettuno
const neptune = new Body("NEPTUNE", 1.024e26, 30.07 * AU, 0, 0, 5400, 8, "#4477dd", 2.4622e7);
// Plutone
const pluto = new Body("PLUTO", 1.309e22, 39.48 * AU, 0, 0, 4700, 3, "#ddccaa", 1.1883e6);


const bodies = [ sun, mercury, venus, earth, moon, mars, jupiter, saturn, uranus, neptune, pluto ];

createOuterAsteroidBelt(300, 40, 55);//300 asteroidi tra 40->55 AU

function animate(){
	if (!paused){
		ctx.clearRect(0,0,canvas.width,canvas.height);

		/*
		for(let body of bodies){
			body.updateForces(bodies);
		}

		for(let body of bodies){
			body.updatePosition();
			body.updatePath();
		}
		*/
		
		// 1. Calcoliamo le accelerazioni ATTUALI (a_t) per tutti
        // Invece di sovrascrivere body.ax subito, usiamo una costante temporanea
        // o assicuriamoci che il calcolo sia atomico.
        let accelerations = bodies.map(body => body.computeAcceleration(bodies));

        // 2. Aggiorniamo le POSIZIONI di tutti
        for (let i = 0; i < bodies.length; i++) {
            let b = bodies[i];
            let a = accelerations[i];
            
            // x(t + dt) = x(t) + v(t)*dt + 0.5 * a(t) * dt^2
            b.x += b.vx * TIME_STEP + 0.5 * a.ax * TIME_STEP * TIME_STEP;
            b.y += b.vy * TIME_STEP + 0.5 * a.ay * TIME_STEP * TIME_STEP;
            
            // Memorizziamo l'accelerazione vecchia per il calcolo della velocità dopo
            b.ax = a.ax;
            b.ay = a.ay;
			
			b.updatePath();
        }

        // 3. Aggiorniamo le VELOCITÀ di tutti
        for (let b of bodies) {
            // Calcoliamo la NUOVA accelerazione (a_t+dt) nella nuova posizione
            let newAcc = b.computeAcceleration(bodies);
            
            // v(t + dt) = v(t) + 0.5 * (a(t) + a(t + dt)) * dt
            b.vx += 0.5 * (b.ax + newAcc.ax) * TIME_STEP;
            b.vy += 0.5 * (b.ay + newAcc.ay) * TIME_STEP;
        }
		
				
		if (autocenter) {
			if (forcedCenterBody) {
				// centriamo sul corpo selezionato
				CENTER_X = canvas.width / 2 - forcedCenterBody.x * SCALE * zoom;
				CENTER_Y = canvas.height / 2 - forcedCenterBody.y * SCALE * zoom;
			} else {
				// centro di massa
				const cm = computeCenterOfMass(bodies);
				CENTER_X = canvas.width / 2 - cm.x * SCALE * zoom;
				CENTER_Y = canvas.height / 2 - cm.y * SCALE * zoom;
			}
		}
		
		checkCollisions();
		
		for (let body of bodies) {
			if (PATH) body.drawPath();

			body.draw();
		}
		
		drawStats();
	}
	
    requestAnimationFrame(animate);
}

//zoom
canvas.addEventListener("wheel", (e) => {
    e.preventDefault();

    const zoomFactor = 1.1;
    const mouseX = e.clientX;
    const mouseY = e.clientY;

    const worldX = (mouseX - CENTER_X) / (zoom * SCALE);
    const worldY = (mouseY - CENTER_Y) / (zoom * SCALE);

    if (e.deltaY < 0) zoom *= zoomFactor;
    else zoom /= zoomFactor;

    CENTER_X = mouseX - worldX * zoom * SCALE;
    CENTER_Y = mouseY - worldY * zoom * SCALE;
	
	document.getElementById("ZOOM").innerHTML=zoom;
});

//click
canvas.addEventListener("click", (e) => {

    const mouseX = e.clientX;
    const mouseY = e.clientY;

    // coordinate mondo prima del click
    const worldX = (mouseX - CENTER_X) / (zoom * SCALE);
    const worldY = (mouseY - CENTER_Y) / (zoom * SCALE);

    // nuovo offset per mettere quel punto al centro
    CENTER_X = canvas.width / 2 - worldX * zoom * SCALE;
    CENTER_Y = canvas.height / 2 - worldY * zoom * SCALE;
});

//autocenter su pianeta
let forcedCenterBody = null; // corpo su cui centrare con i tasti

// Gestione tasti
window.addEventListener("keydown", (e) => {
    let index = -1;
    if (e.key >= "1" && e.key <= "9") index = parseInt(e.key);
    else if (e.key === "0") index = 10; // Plutone

    if (index >= 0 && index < bodies.length) {
        forcedCenterBody = bodies[index];
    }
    // tasto S per Sole
    if (e.key === "s" || e.key === "S") forcedCenterBody = bodies[0];
});

let newSunIdx = 0;
canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault(); // evita il menu di default del browser
	const mouseX = e.clientX;
    const mouseY = e.clientY;
	const worldX = (mouseX - CENTER_X) / (zoom * SCALE);
    const worldY = (mouseY - CENTER_Y) / (zoom * SCALE);
	newSunIdx++;
	let mass = parseFloat(prompt("Insert SUN"+newSunIdx+" mass (in kg, default = SUN mass / 4)", sun.mass/4));
	let realRadius = parseFloat(prompt("Insert SUN"+newSunIdx+" radius (in m, default = SUN radius / 3)", sun.realRadius/3));
	let speedX = parseFloat(prompt("Insert SUN"+newSunIdx+" vx (in m/s, default = -5000)", -5000));
	let speedY = parseFloat(prompt("Insert SUN"+newSunIdx+" vy (in m/s, default = 5000)", 5000));
	let radius = parseFloat(prompt("Insert SUN"+newSunIdx+" draw radius (in px, default = 10)", 10));
    const sun2 = new Body(
            "SUN"+newSunIdx,
            mass,//massa
            worldX,
            worldY,
            speedX, 
			speedY,         // velocità iniziale
            radius,         // raggio render più piccolo
            "#ffff99",      // colore leggermente diverso
            realRadius      //raggio
    );
    const acc = sun2.computeAcceleration(bodies);
    sun2.ax = acc.ax;
    sun2.ay = acc.ay;
    bodies.push(sun2);
});



function fixCenterOfMass(bodies){
    let totalMass = 0;
    let px = 0;
    let py = 0;

    for (let b of bodies){
        totalMass += b.mass;
        px += b.mass * b.vx;
        py += b.mass * b.vy;
    }

    const vxCM = px / totalMass;
    const vyCM = py / totalMass;

    for (let b of bodies){
        b.vx -= vxCM;
        b.vy -= vyCM;
    }
}

function computeCenterOfMass(bodies){
    let totalMass = 0;
    let x = 0;
    let y = 0;

    for (let b of bodies){
        totalMass += b.mass;
        x += b.mass * b.x;
        y += b.mass * b.y;
    }

    return {
        x: x / totalMass,
        y: y / totalMass
    };
}

function drawStats() {
	bodies.forEach(item => { 
		let exists = document.getElementById(item.name) != null;
		if(exists) {
			document.getElementById(item.name).innerHTML = 
			'<span style="color: '+item.color+'">' + item.name + '</span>:' +
			' mass=' + item.mass + 'kg ' +
			' radius=' + item.realRadius + 'm ' +
			' x=' + item.x + 'm ' +
			' y=' + item.y + 'm ' +
			' vx=' + item.vx + 'm/s ' +
			' vy=' + item.vy + 'm/s '
		}
	});
	document.getElementById("OBJECTS").innerHTML = bodies.length;
	document.getElementById("PATHLEN").innerHTML = bodies.length > 2 ? bodies[1].path.length : bodies[0].path.length;
}


//GESTIONE COLLISIONI
function checkCollisions() {
    for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {

            const b1 = bodies[i];
            const b2 = bodies[j];

            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            const collisionDistance = b1.realRadius + b2.realRadius;

			if (dist < collisionDistance * 32 && TIME_STEP > 86400) {
				TIME_STEP /= 2;
				document.getElementById('TS').innerHTML=TIME_STEP;
			}
			
			if (dist < collisionDistance * 16 && TIME_STEP > 10800) {
				TIME_STEP /= 2;
				document.getElementById('TS').innerHTML=TIME_STEP;
			}
			
            if (dist <= collisionDistance * 4) {
				resolveImpact(b1, b2, dist, dx, dy);
                return;
            }
        }
    }
}
//impatto fonde o frantuma?
function resolveImpact(b1, b2, dist, dx, dy) {

    const dvx = b1.vx - b2.vx;//delta velocita x
    const dvy = b1.vy - b2.vy;//delta velocita y

    const reducedMass = (b1.mass * b2.mass) / (b1.mass + b2.mass);
    const relativeSpeedSq = dvx*dvx + dvy*dvy;

    const kineticEnergy = 0.5 * reducedMass * relativeSpeedSq;//1/2mv2

    const gravitationalBinding = G * b1.mass * b2.mass / (b1.realRadius + b2.realRadius);

    if (kineticEnergy > gravitationalBinding) {
        fragmentBodies(b1, b2);
    } else {
        mergeBodies(b1, b2);
    }
}
//fusione
function mergeBodies(b1, b2){

    const newMass = b1.mass + b2.mass;

    const newVx =
        (b1.mass*b1.vx + b2.mass*b2.vx) / newMass;

    const newVy =
        (b1.mass*b1.vy + b2.mass*b2.vy) / newMass;

    const newX =
        (b1.mass*b1.x + b2.mass*b2.x) / newMass;

    const newY =
        (b1.mass*b1.y + b2.mass*b2.y) / newMass;

    const newRealRadius = Math.cbrt(
        Math.pow(b1.realRadius,3) +
        Math.pow(b2.realRadius,3)
    );

    const merged = new Body(
        b1.name + "+" + b2.name,
        newMass,
        newX,
        newY,
        newVx,
        newVy,
        Math.cbrt(b1.radius**3 + b2.radius**3),
        "#ffff55",
        newRealRadius
    );

    bodies.splice(bodies.indexOf(b1),1);
    bodies.splice(bodies.indexOf(b2),1);
    bodies.push(merged);
	forcedCenterBody = merged;
}
//frantumazione
function fragmentBodies(b1, b2){
    const fragments = 100;
    const totalMass = b1.mass + b2.mass;

    // Velocità e quantità di moto centro di massa
    const px = b1.mass*b1.vx + b2.mass*b2.vx;
    const py = b1.mass*b1.vy + b2.mass*b2.vy;
    const vcmX = px / totalMass;
    const vcmY = py / totalMass;

    // Posizione centro di massa
    const centerX = (b1.mass*b1.x + b2.mass*b2.x) / totalMass;
    const centerY = (b1.mass*b1.y + b2.mass*b2.y) / totalMass;

    // Energia cinetica totale dei due corpi
    const kineticBefore = 0.5 * b1.mass * (b1.vx**2 + b1.vy**2) +
                          0.5 * b2.mass * (b2.vx**2 + b2.vy**2);

    // Percentuale di energia da distribuire ai frammenti
    const explosionEnergyFraction = 0.01; // 10% dell'energia totale viene ai frammenti
    const energyForFragments = kineticBefore * explosionEnergyFraction;

    const massPerFragment = totalMass / fragments;

    // Energia per frammento
    const energyPerFragment = energyForFragments / fragments;

    for (let i = 0; i < fragments; i++) {

        const angle = Math.random() * 2 * Math.PI;

        // Modulo della velocità del frammento da energia cinetica
        const speed = Math.sqrt(2 * energyPerFragment / massPerFragment);

        // Velocità totale = centro massa + esplosione
        const vx = vcmX + Math.cos(angle) * speed;
        const vy = vcmY + Math.sin(angle) * speed;

        const frag = new Body(
            "frag",
            massPerFragment,
            centerX,
            centerY,
            vx,
            vy,
            2,
            "#ffaa00",
            1e6
        );

        bodies.push(frag);
    }

    // Rimuovi corpi originali
    bodies.splice(bodies.indexOf(b1),1);
    bodies.splice(bodies.indexOf(b2),1);
}


function createOuterAsteroidBelt(count = 100, innerAU = 40, outerAU = 55){
    for(let i = 0; i < count; i++){
        const r = (innerAU + Math.random()*(outerAU-innerAU)) * AU;
        const angle = Math.random() * 2*Math.PI;

        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);

        // velocità orbitale circolare
        const v = Math.sqrt(G * sun.mass / r);

        // direzione tangenziale
        const vx = -v * Math.sin(angle);
        const vy =  v * Math.cos(angle);

        const asteroid = new Body(
            "AST" + i,
            1e18,                 // massa piccola
            x,
            y,
            vx,
            vy,
            1.5,                  // raggio render piccolo
            "#888888",
            5e5                   // raggio reale
        );

        bodies.push(asteroid);
    }
}




fixCenterOfMass(bodies);

animate();

</script>
</body>
</html>
