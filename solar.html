<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, height=device-height, maximum-scale=1.0">
<title>Sistema Solare</title>
<style>
body { margin:0; background:black; overflow:hidden; font-family: monospace; color: #fff; }
canvas { display:block; touch-action: none; }
#controls { position: absolute; top:0; left:0; overflow: hidden; z-index: 10; }
#info { position: absolute; bottom:0; left:0; color: #333; overflow: hidden; filter: opacity(0.9); }
p { margin: 0 0 0 10px; }
.planet { display: flex; justify-content: flex-start; align-items: center; white-space: nowrap; overflow: hidden; }
button { min-width: 30px; min-height: 30px; }
</style>
</head>
<body>
<div id="controls">
	<button onclick="TIME_STEP /= ts;document.getElementById('TS').innerHTML=TIME_STEP">-</button>
	TIMESTEP
	<button onclick="TIME_STEP *= ts;document.getElementById('TS').innerHTML=TIME_STEP">+</button>
	= <span id="TS">86400</span>
	<br/>
	<button onclick="autocenter=!autocenter;document.getElementById('AC').innerHTML=autocenter">AUTOCENTER</button>
	= <span id="AC">true</span>
	<br/>
	<button onclick="zoom=1;document.getElementById('ZOOM').innerHTML=zoom">Z</button>MOUSE WHEEL = ZOOM = <span id="ZOOM">1</span>
	<br/>
	MOUSE CLICK = CENTER
	<br/>
	AUTOCENTER 0..9 / S=sun / C=center of mass
	<br/>
	MOUSE RIGHT CLICK = ADD SUN
	<br/>
	<button onclick="forcedCenterBody=null;autocenter=true;document.getElementById('AC').innerHTML=autocenter;">C</button>CENTER OF MASS = <span id="CENTEROFMASS"></span>
	<br/>
	<button onclick="paused=!paused;document.getElementById('PAUSED').innerHTML=paused">PAUSED</button>
	= <span id="PAUSED">false</span>
	<br/>
	<button onclick="BORDER=!BORDER;document.getElementById('BORDER').innerHTML=BORDER">BORDER</button>
	= <span id="BORDER">true</span>
	<br/>
	<button onclick="LABEL=!LABEL;document.getElementById('LABEL').innerHTML=LABEL">LABEL</button>
	= <span id="LABEL">true</span>
	<br/>
	<button onclick="PATH=!PATH;document.getElementById('PATH').innerHTML=PATH">PATH</button>
	= <span id="PATH">true</span>
	<br/>
	OBJECTS = <span id="OBJECTS"></span>
	<br/>
	PATH LEN = <span id="PATHLEN"></span>
	<br/>
	EXPLO COUNT = <span id="EXPLOCOUNT"></span>
	<br/>
	MERGE COUNT = <span id="MERGECOUNT"></span>
	<br/>
	<button onclick="if(document.getElementById('info').style.display=='none')document.getElementById('info').style.display='block';else document.getElementById('info').style.display='none';">INFO</button>
</div>
<div id="info" style="display:none"></div>

<canvas id="space"></canvas>

<script>

// ===== COSTANTI REALI =====
const G = 6.67430e-11;//costante gravitazione universale
const AU = 1.496e11;//unita astronomica
const DAY = 86400;//secondi
const SCALE = 90 / AU;
let zoom = 1;
let TIME_STEP = DAY * 1; //1 giorno per frame (più stabile con Mercurio)
let autocenter = true;//centra vista sul centro di massa CM calcolato ogni frame
let paused = false;//pausa on/off
let spd = 1.05;//speed +/-
let mass = 1.05;//mass +/-
let ts = 2;//time step +/-
let BORDER = true;
let LABEL = true;
let PATH = true;
let exploCount = 0;
let mergeCount = 0;

const canvas = document.getElementById("space");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let CENTER_X = canvas.width/2;
let CENTER_Y = canvas.height/2;

class Body {
    constructor(name, mass, x, y, z, vx, vy, vz, radius, color, realRadius){
        this.name = name;
        this.mass = mass;
        this.x = x;
        this.y = y;
		this.z = z;
        this.vx = vx;
        this.vy = vy;
		this.vz = vz;
        this.radius = radius;//px per render
		this.realRadius = realRadius;
        this.color = color;
		this.path = [];//percorso=posizioni passate
		this.pathIndex = 0;
		this.ax = 0;//accelerazione corrente (x)
		this.ay = 0;//accelerazione corrente (y)
		this.az = 0;//accelerazione corrente (z)
    }

	/*
    updateForces(bodies){
        let ax = 0;
        let ay = 0;

        for(let other of bodies){
            if(other === this) continue;

            const dx = other.x - this.x;
            const dy = other.y - this.y;
            const distSq = dx*dx + dy*dy;
            const dist = Math.sqrt(distSq);

            const a = G * other.mass / distSq;

            ax += a * dx / dist;
            ay += a * dy / dist;
        }

        this.vx += ax * TIME_STEP;
        this.vy += ay * TIME_STEP;
    }
	
    updatePosition() {
		this.x += this.vx * TIME_STEP;
		this.y += this.vy * TIME_STEP;
	}
	*/
	
	updatePath() {
		const maxLen = Math.floor(50000 / bodies.length);//lunghezza massima path, circa 5000 per pianeta
		const lastIdx = this.path.length - 1;
		const lastPos = lastIdx === -1 ? { x: 0, y: 0 } : this.path[lastIdx];

		// distanza in pixel sul canvas dal punto precedente
		const dx = (this.x - lastPos.x) * SCALE * zoom;
		const dy = (this.y - lastPos.y) * SCALE * zoom;
		const dist = Math.sqrt(dx*dx + dy*dy);
		const thresholdPx = 20;//distanza minima in px per aggiungere un nuovo punto
		
		//angolo attuale rispetto al sole
		const angle = Math.atan2(this.y, this.x);//this.y - sun.y, this.x - sun.x);//voglio vedere oscillazioni del sole!!!
		const lastAngle = Math.atan2(lastPos.y, lastPos.x);
		let deltaAngle = Math.abs(angle - lastAngle);
		deltaAngle = deltaAngle % (2*Math.PI);
		if (deltaAngle > Math.PI) deltaAngle = 2*Math.PI - deltaAngle;
		const thresholdAngle = Math.PI / 180 * 10;//10 gradi in radianti
		
		if (dist > thresholdPx || deltaAngle > thresholdAngle) {
			if (this.path.length >= maxLen) {
				this.path[this.pathIndex] = { x: this.x, y: this.y };
				this.pathIndex = (this.pathIndex + 1) % maxLen;
			} else {
				this.path.push({ x: this.x, y: this.y });
			}
		}
	}


    draw(){
		const px = CENTER_X + this.x * SCALE * zoom;
		const py = CENTER_Y + this.y * SCALE * zoom;
		const zf = zoom / 50;
		const r = this.radius * zf;//

		// Disegno base pianeta
		ctx.beginPath();
		ctx.arc(px, py, r, 0, Math.PI*2);
		ctx.fillStyle = this.color;
		ctx.fill();

		if (this !== sun && this.name.indexOf("SUN") === -1) {
			// ===== DIREZIONE LUCE DAL SOLE =====
			const dx = sun.x - this.x;
			const dy = sun.y - this.y;
			const angle = Math.atan2(dy, dx);

			ctx.save();

			// Clip al cerchio del pianeta
			ctx.beginPath();
			ctx.arc(px, py, r, 0, Math.PI*2);
			ctx.clip();

			// Impostiamo modalità moltiplicazione (ombra realistica)
			ctx.globalCompositeOperation = "multiply";

			// Creiamo gradiente ombra
			const shadowGradient = ctx.createLinearGradient(
				px - Math.cos(angle) * r,
				py - Math.sin(angle) * r,
				px + Math.cos(angle) * r,
				py + Math.sin(angle) * r
			);

			shadowGradient.addColorStop(0, "rgba(0,0,0,1)");
			shadowGradient.addColorStop(0.5, "rgba(0,0,0,0.25)");
			shadowGradient.addColorStop(1, "rgba(0,0,0,0)");

			ctx.fillStyle = shadowGradient;
			ctx.fillRect(px - r, py - r, r*2, r*2);
			ctx.restore();
			
			//saturn ringsss
			if (this === saturn) {				
				ctx.beginPath();
				ctx.strokeStyle="rgba(200,180,120,0.25)";
				ctx.lineWidth = 5 * zf;
				ctx.ellipse(px, py, r*2.2, r*3.2, Math.PI/4, 0, Math.PI*2);
				ctx.stroke();
				ctx.lineWidth = 1;
			}			
		} else {
			ctx.shadowColor = this.color;
			ctx.shadowBlur = r * 3; // più grande = glow più ampio
			ctx.fill();
		}
		
		if(BORDER){
			ctx.strokeStyle = "#fff";
			ctx.stroke();
		}

		if(LABEL){
			ctx.fillStyle = "#fff";
			ctx.fillText(
				this.name,
				px + r * Math.sqrt(zoom) + 10,
				py - r * Math.sqrt(zoom) - 10
			);
		}
	}

	
	drawPath(){
		if(this.path.length < 1) return;

		ctx.fillStyle = this.color;
		
		for(let i = 0; i < this.path.length; i++){
			const px = CENTER_X + this.path[i].x * SCALE * zoom;
			const py = CENTER_Y + this.path[i].y * SCALE * zoom;
			ctx.fillRect(px-0.5, py-0.5, 1, 1);
		}
	}

	computeAcceleration(bodies){
		let ax = 0;
		let ay = 0;
		let az = 0;

		for(let other of bodies){
			if(other === this) continue;

			const dx = other.x - this.x;
			const dy = other.y - this.y;
			const dz = other.z - this.z;
			
			const minDist = other.realRadius + this.realRadius;
			const distSq = Math.max(dx*dx + dy*dy + dz*dz, minDist*minDist);
			
			const invDist = 1 / Math.sqrt(distSq); // softening
			const invDist3 = invDist * invDist * invDist;
			
			ax += G * other.mass * dx * invDist3;
			ay += G * other.mass * dy * invDist3;
			az += G * other.mass * dz * invDist3;
		}

		return { ax, ay, az };
	}

}

// ===== CORPI =====
//name, mass, 
//x, y, z, 
//vx, vy, vz, 
//radius, color, realRadius

//sole circa 10 volte giove
//giove appena piu grande saturno
//giove 3 volte nettuno
//giove 11 volte la terra
//nettuno 4 volte la terra
//sole 400 volte la luna
// Sole
const sun = new Body("SUN", 1.989e30, 
0,0,0,
0,0,0,
50, "#ffffdd", 6.9634e8);
// Mercurio
const mercury = new Body("MERCURY", 3.301e23,
0.387 * AU, 0, 0,
0, 47870, 0,
5, "#cc9988", 2.4397e6);
// Venere
const venus = new Body("VENUS", 4.867e24,
0.723 * AU, 0, 0,
0, 35020, 0,
6, "#ddddaa", 6.0518e6);
// Terra
const earth = new Body("EARTH", 5.972e24, 
AU, 0, 0, 
0, 29780, 0,
7, "#4499ee", 6.371e6);
// Luna
const moon = new Body("MOON", 7.342e22, 
AU + 384400000, 0, 0,
0, 29780 + 1022, 0,
2, "#eeeeee", 1.7371e6);
// Marte
const mars = new Body("MARS", 6.39e23, 
1.524 * AU, 0, 0,
0, 24077, 0,
6, "#cc3322", 3.3895e6);
// Giove
const jupiter = new Body("JUPITER", 1.898e27, 
5.204 * AU, 0, 0,
0, 13070, 0,
10, "#cc9966", 6.9911e7);
// Saturno
const saturn = new Body("SATURN", 5.683e26, 
9.582 * AU, 0, 0,
0, 9680, 0,
9, "#eecc99", 5.8232e7);
// Urano
const uranus = new Body("URANUS", 8.681e25, 
19.191 * AU, 0, 0,
0, 6800, 0,
8, "#77ddff", 2.5362e7);
// Nettuno
const neptune = new Body("NEPTUNE", 1.024e26, 
30.07 * AU, 0, 0, 
0, 5400, 0,
7, "#4477dd", 2.4622e7);
// Plutone
const pluto = new Body("PLUTO", 1.309e22, 
39.48 * AU, 0, 0,
0, 4700, 0,
6, "#ddccaa", 1.1883e6);


const bodies = [ sun, mercury, venus, earth, moon, mars, jupiter, saturn, uranus, neptune, pluto ];

createOuterAsteroidBelt(100, 40, 55);//100 asteroidi tra 40->55 AU

rebuildInfoPanel();

function animate(){
	ctx.clearRect(0,0,canvas.width,canvas.height);

	/*
	for(let body of bodies){
		body.updateForces(bodies);
	}

	for(let body of bodies){
		body.updatePosition();
		body.updatePath();
	}
	*/
		
	if (!paused){
		// 1. Calcoliamo le accelerazioni ATTUALI (a_t) per tutti
		// Invece di sovrascrivere body.ax subito, usiamo una costante temporanea
        // o assicuriamoci che il calcolo sia atomico.
        let accelerations = bodies.map(body => body.computeAcceleration(bodies));

        // 2. Aggiorniamo le POSIZIONI di tutti
        for (let i = 0; i < bodies.length; i++) {
            let b = bodies[i];
            let a = accelerations[i];
            
            // x(t + dt) = x(t) + v(t)*dt + 0.5 * a(t) * dt^2
            b.x += b.vx * TIME_STEP + 0.5 * a.ax * TIME_STEP * TIME_STEP;
            b.y += b.vy * TIME_STEP + 0.5 * a.ay * TIME_STEP * TIME_STEP;
			b.z += b.vz * TIME_STEP + 0.5 * a.az * TIME_STEP * TIME_STEP;
			
			// Memorizziamo l'accelerazione vecchia per il calcolo della velocità dopo
            b.ax = a.ax;
            b.ay = a.ay;
			b.az = a.az;
			
			b.updatePath();
        }

        // 3. Aggiorniamo le VELOCITÀ di tutti
        for (let b of bodies) {
            // Calcoliamo la NUOVA accelerazione (a_t+dt) nella nuova posizione
            let newAcc = b.computeAcceleration(bodies);
            
            // v(t + dt) = v(t) + 0.5 * (a(t) + a(t + dt)) * dt
            b.vx += 0.5 * (b.ax + newAcc.ax) * TIME_STEP;
            b.vy += 0.5 * (b.ay + newAcc.ay) * TIME_STEP;
			b.vz += 0.5 * (b.az + newAcc.az) * TIME_STEP;
        }
	}
				
	if (autocenter) {
		if (forcedCenterBody) {
			// centriamo sul corpo selezionato
			CENTER_X = canvas.width / 2 - forcedCenterBody.x * SCALE * zoom;
			CENTER_Y = canvas.height / 2 - forcedCenterBody.y * SCALE * zoom;
			ctx.fillText('CENTER OF OBJECT', canvas.width / 2 - 50, 10);
		} else {
			// centro di massa
			const cm = computeCenterOfMass(bodies);
			CENTER_X = canvas.width / 2 - cm.x * SCALE * zoom;
			CENTER_Y = canvas.height / 2 - cm.y * SCALE * zoom;
			ctx.fillText('CENTER OF MASS', canvas.width / 2 - 50, 10);
		}
		// disegna il centro (di massa?)
		ctx.strokeStyle = '#fff';
		ctx.lineWidth = 0.2;
		ctx.beginPath();
		ctx.moveTo(canvas.width / 2, 0);
		ctx.lineTo(canvas.width / 2, canvas.height);
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(0, canvas.height / 2);
		ctx.lineTo(canvas.width, canvas.height / 2);
		ctx.stroke();
	}
	
	checkCollisions();
	
	for (let body of bodies) {
		if (PATH) body.drawPath();

		body.draw();
	}
	
	drawStats();
	
	
    requestAnimationFrame(animate);
}

//zoom
canvas.addEventListener("wheel", (e) => {
    e.preventDefault();

    const zoomFactor = 1.1;
    const mouseX = e.clientX;
    const mouseY = e.clientY;

    const worldX = (mouseX - CENTER_X) / (zoom * SCALE);
    const worldY = (mouseY - CENTER_Y) / (zoom * SCALE);

    if (e.deltaY < 0) zoom *= zoomFactor;
    else zoom /= zoomFactor;

    CENTER_X = mouseX - worldX * zoom * SCALE;
    CENTER_Y = mouseY - worldY * zoom * SCALE;
	
	document.getElementById("ZOOM").innerHTML=zoom;
});

//gestione click
canvas.addEventListener("click", (e) => {
    handleLeftClick(e);
});
function handleLeftClick(pointer) {
    const mouseX = pointer.clientX;
    const mouseY = pointer.clientY;
	//coordinate world prima del click
    const worldX = (mouseX - CENTER_X) / (zoom * SCALE);
    const worldY = (mouseY - CENTER_Y) / (zoom * SCALE);
	//nuovo offset per centrare rispetto a quel punto
    CENTER_X = canvas.width / 2 - worldX * zoom * SCALE;
    CENTER_Y = canvas.height / 2 - worldY * zoom * SCALE;
}


//autocenter su pianeta
let forcedCenterBody = null; // corpo su cui centrare con i tasti

// Gestione tasti
window.addEventListener("keydown", (e) => {
    let index = -1;
    if (e.key >= "1" && e.key <= "9") index = parseInt(e.key);
    else if (e.key === "0") index = 10; // Plutone

    if (index >= 0 && index < bodies.length) {
        forcedCenterBody = bodies[index];
    }
    // tasto S per Sole
    if (e.key === "s" || e.key === "S") forcedCenterBody = bodies[0];
	if (e.key === "c" || e.key === "C") forcedCenterBody = null;
	if (e.key === "z" || e.key === "Z") zoom = 1;
});


//gestione click destro
canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    handleRightClick(e);
});
let newSunIdx = 0;
function handleRightClick(pointer) {

    const mouseX = pointer.clientX;
    const mouseY = pointer.clientY;

    const worldX = (mouseX - CENTER_X) / (zoom * SCALE);
    const worldY = (mouseY - CENTER_Y) / (zoom * SCALE);

    newSunIdx++;

    let mass = parseFloat(prompt("Insert SUN"+newSunIdx+" mass", sun.mass/4)) || sun.mass/4;
    let realRadius = parseFloat(prompt("Insert SUN"+newSunIdx+" radius", sun.realRadius/3)) || sun.realRadius/3;
    let speedX = parseFloat(prompt("Insert SUN"+newSunIdx+" vx", -5000)) || 0;
    let speedY = parseFloat(prompt("Insert SUN"+newSunIdx+" vy", 5000)) || 0;
	let speedZ = parseFloat(prompt("Insert SUN"+newSunIdx+" vz", 0)) || 0;
	let posZ = parseFloat(prompt("Insert SUN"+newSunIdx+" z", 0)) || 0;
    let radius = parseFloat(prompt("Insert SUN"+newSunIdx+" draw radius", 10)) || 10;

    const sun2 = new Body(
        "SUN"+newSunIdx,
        mass,
        worldX,
        worldY,
		posZ,
        speedX,		// velocità iniziale x
        speedY,		// velocità iniziale x
		speedZ,		// velocità iniziale z
        radius,		// raggio render più piccolo
        "#ffff99",	// colore leggermente diverso
        realRadius	//raggio
    );

    const acc = sun2.computeAcceleration(bodies);
    sun2.ax = acc.ax;
    sun2.ay = acc.ay;
	sun2.az = acc.az;

    bodies.push(sun2);
}

//gestione zoom mobile
let initialDistance = null;
let initialZoom = null;
canvas.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2) {
        e.preventDefault();

        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx*dx + dy*dy);

        if (!initialDistance) {
            initialDistance = distance;
            initialZoom = zoom;
        } else {
            zoom = initialZoom * (distance / initialDistance);
            document.getElementById("ZOOM").innerHTML = zoom;
        }
    }
}, { passive: false });
canvas.addEventListener("touchend", () => {
    initialDistance = null;
});




function fixCenterOfMass(bodies){
    let totalMass = 0;
    let px = 0;
    let py = 0;
	let pz = 0;

    for (let b of bodies){
        totalMass += b.mass;
        px += b.mass * b.vx;
        py += b.mass * b.vy;
		pz += b.mass * b.vz;
    }

    const vxCM = px / totalMass;
    const vyCM = py / totalMass;
	const vzCM = pz / totalMass;

    for (let b of bodies){
        b.vx -= vxCM;
        b.vy -= vyCM;
		b.vz -= vzCM;
    }
}

function computeCenterOfMass(bodies){
    let totalMass = 0;
    let x = 0;
    let y = 0;
	let z = 0;

    for (let b of bodies){
        totalMass += b.mass;
        x += b.mass * b.x;
        y += b.mass * b.y;
		z += b.mass * b.z;
    }

    return {
        x: x / totalMass,
        y: y / totalMass,
		z: z / totalMass
    };
}

//mostro i dati in formato esponenziale con un paio di decimali
function drawStats() {
	bodies.forEach(item => { 
		let exists = document.getElementById(item.name) != null;
		if(exists) {
			document.getElementById(item.name).innerHTML = 
			'<span style="color: '+item.color+'">' + item.name + '</span>:' +
			' mass=' + (item.mass.toExponential(2)) + 'kg ' +
			' radius=' + (item.realRadius.toExponential(2)) + 'm ' +
			' x=' + (item.x.toExponential(2)) + 'm ' +
			' y=' + (item.y.toExponential(2)) + 'm ' +
			' z=' + (item.z.toExponential(2)) + 'm ' +
			' vx=' + (item.vx.toExponential(2)) + 'm/s ' +
			' vy=' + (item.vy.toExponential(2)) + 'm/s ' + 
			' vz=' + (item.vz.toExponential(2)) + 'm/s '
		}
	});
	document.getElementById("OBJECTS").innerHTML = bodies.length;
	document.getElementById("PATHLEN").innerHTML = bodies.length > 2 ? bodies[1].path.length : bodies[0].path.length;
	document.getElementById("EXPLOCOUNT").innerHTML = exploCount;
	document.getElementById("MERGECOUNT").innerHTML = mergeCount;
	
	const cm = computeCenterOfMass(bodies);
	document.getElementById("CENTEROFMASS").innerHTML = "x=" + (cm.x.toExponential(2)) + "m y=" + (cm.y.toExponential(2))+"m z=" + (cm.z.toExponential(2))+"m";
}


//GESTIONE COLLISIONI
function checkCollisions() {
    for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {

            const b1 = bodies[i];
            const b2 = bodies[j];

            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
			const dz = b2.z - b1.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            const collisionDistance = b1.realRadius + b2.realRadius;

			if (dist < collisionDistance * 32 && TIME_STEP > 5400) {
				TIME_STEP /= 2;
				document.getElementById('TS').innerHTML=TIME_STEP;
			}
				
			if (dist <= collisionDistance * 4) {
				resolveImpact(b1, b2, dist, dx, dy, dz);
                return;
            }
        }
    }
}
//impatto fonde o frantuma?
function resolveImpact(b1, b2, dist, dx, dy, dz) {

    const dvx = b1.vx - b2.vx;//delta velocita x
    const dvy = b1.vy - b2.vy;//delta velocita y
	const dvz = b1.vz - b2.vz;//delta velocita z

    const reducedMass = (b1.mass * b2.mass) / (b1.mass + b2.mass);
    const relativeSpeedSq = dvx*dvx + dvy*dvy + dvz*dvz;

    const kineticEnergy = 0.5 * reducedMass * relativeSpeedSq;//1/2mv2

    const gravitationalBinding = G * b1.mass * b2.mass / (b1.realRadius + b2.realRadius);

    if (kineticEnergy > gravitationalBinding) {
        fragmentBodies(b1, b2);
		exploCount++;
		rebuildInfoPanel();
    } else {
        mergeBodies(b1, b2);
		mergeCount++;
		rebuildInfoPanel();
    }
}
//fusione
function mergeBodies(b1, b2){

    const newMass = b1.mass + b2.mass;

    const newVx = (b1.mass*b1.vx + b2.mass*b2.vx) / newMass;
    const newVy = (b1.mass*b1.vy + b2.mass*b2.vy) / newMass;
	const newVz = (b1.mass*b1.vz + b2.mass*b2.vz) / newMass;

    const newX = (b1.mass*b1.x + b2.mass*b2.x) / newMass;
    const newY = (b1.mass*b1.y + b2.mass*b2.y) / newMass;
	const newZ = (b1.mass*b1.z + b2.mass*b2.z) / newMass;

    const newRealRadius = Math.cbrt(
        Math.pow(b1.realRadius,3) +
        Math.pow(b2.realRadius,3)
    );

    const merged = new Body(
        b1.name + "+" + b2.name,
        newMass,
        newX,
        newY,
		newZ,
        newVx,
        newVy,
		newVz,
        Math.cbrt(b1.radius**3 + b2.radius**3),
        "#ffff55",
        newRealRadius
    );

    bodies.splice(bodies.indexOf(b1),1);
    bodies.splice(bodies.indexOf(b2),1);
    bodies.push(merged);
	forcedCenterBody = merged;
}
//frantumazione
function fragmentBodies(b1, b2){
    const fragments = 100;
    const totalMass = b1.mass + b2.mass;

    // Velocità e quantità di moto centro di massa
    const px = b1.mass*b1.vx + b2.mass*b2.vx;
    const py = b1.mass*b1.vy + b2.mass*b2.vy;
	const pz = b1.mass*b1.vz + b2.mass*b2.vz;
    const vcmX = px / totalMass;
    const vcmY = py / totalMass;
	const vcmZ = pz / totalMass;

    // Posizione centro di massa
    const centerX = (b1.mass*b1.x + b2.mass*b2.x) / totalMass;
    const centerY = (b1.mass*b1.y + b2.mass*b2.y) / totalMass;
	const centerZ = (b1.mass*b1.z + b2.mass*b2.z) / totalMass;

    // Energia cinetica totale dei due corpi
    const kineticBefore = 0.5 * b1.mass * (b1.vx**2 + b1.vy**2 + b1.vz**2) +
                          0.5 * b2.mass * (b2.vx**2 + b2.vy**2 + b2.vz**2);

    // Percentuale di energia da distribuire ai frammenti
    const explosionEnergyFraction = 0.01; // 10% dell'energia totale viene ai frammenti
    const energyForFragments = kineticBefore * explosionEnergyFraction;

    const massPerFragment = totalMass / fragments;

    // Energia per frammento
    const energyPerFragment = energyForFragments / fragments;
	const speed = Math.sqrt(2 * energyForFragments / massPerFragment);
	
    for (let i = 0; i < fragments; i++) {

        const angleXY = Math.random() * 2 * Math.PI;//xy
		const angleZ = Math.acos(2 * Math.random() - 1);//z

        const vx = vcmX + speed * Math.sin(angleZ) * Math.cos(angleXY);
        const vy = vcmY + speed * Math.sin(angleZ) * Math.sin(angleXY);
        const vz = vcmZ + speed * Math.cos(angleZ);
		
        const frag = new Body(
            "FRAG",
            massPerFragment,
            centerX,
            centerY,
			centerZ,
            vx,
            vy,
			vz,
            2,
            "#ffaa00",
            1e6
        );

        bodies.push(frag);
    }

    // Rimuovi corpi originali
    bodies.splice(bodies.indexOf(b1),1);
    bodies.splice(bodies.indexOf(b2),1);
}


function createOuterAsteroidBelt(count = 100, innerAU = 40, outerAU = 55){
    for(let i = 0; i < count; i++){
        const r = (innerAU + Math.random()*(outerAU-innerAU)) * AU;
        const angle = Math.random() * 2*Math.PI;

        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        const z = (Math.random() - 0.5) * 0.1 * AU; // piccolo offset verticale

        // velocità orbitale circolare
        const v = Math.sqrt(G * sun.mass / r);

        // direzione tangenziale
        const vx = -v * Math.sin(angle);
        const vy =  v * Math.cos(angle);
        const vz = 0; // movimento principale nel piano XY

        const asteroid = new Body(
            "AST" + i,
            1e18,
            x, y, z,
            vx, vy, vz,
            1.5,
            "#888888",
            5e5
        );

        bodies.push(asteroid);
    }
}




function rebuildInfoPanel() {
    const info = document.getElementById("info");
    info.innerHTML = "";

    const maxItems = Math.min(11, bodies.length);
	let done = 0;
    for (let i = 0; i < bodies.length && done < maxItems; i++) {
		const body = bodies[i];
		if (body.name.indexOf("AST") === 0 || body.name.indexOf("FRAG") === 0) continue;
		done++;
		
		const wrapper = document.createElement("div");
        wrapper.className = "planet";

        // MASS LABEL
        const massLabel = document.createElement("p");
        massLabel.textContent = "MASS:";

        const massMinus = document.createElement("button");
        massMinus.textContent = "-";
        massMinus.onclick = () => body.mass /= mass;

        const massPlus = document.createElement("button");
        massPlus.textContent = "+";
        massPlus.onclick = () => body.mass *= mass;

        // SPEED LABEL
        const speedLabel = document.createElement("p");
        speedLabel.textContent = "SPEED:";

        const speedMinus = document.createElement("button");
        speedMinus.textContent = "-";
        speedMinus.onclick = () => {
            body.vx /= spd;
            body.vy /= spd;
        };

        const speedPlus = document.createElement("button");
        speedPlus.textContent = "+";
        speedPlus.onclick = () => {
            body.vx *= spd;
            body.vy *= spd;
        };

        const speedInvert = document.createElement("button");
        speedInvert.textContent = "INV";
        speedInvert.onclick = () => {
            body.vx *= -1;
            body.vy *= -1;
        };

        //INFO TEXT
        const infoText = document.createElement("p");
        infoText.id = body.name;
		
		//CENTER VIEW
		const centerButton = document.createElement("button");
		centerButton.textContent = "C";
		centerButton.onclick = () => { forcedCenterBody = body; autocenter = true; document.getElementById('AC').innerHTML = autocenter; };
		
		wrapper.appendChild(centerButton);
        wrapper.appendChild(massLabel);
        wrapper.appendChild(massMinus);
        wrapper.appendChild(massPlus);
        wrapper.appendChild(speedLabel);
        wrapper.appendChild(speedMinus);
        wrapper.appendChild(speedPlus);
        wrapper.appendChild(speedInvert);
        wrapper.appendChild(infoText);

        info.appendChild(wrapper);
    }
}


//DIO BENEDICA CHATGPT
async function initSolarSystemFromNASA() {
    const ids = {
        sun: '10',
        mercury: '199',
        venus: '299',
        earth: '399',
        moon: '301',
        mars: '499',
        jupiter: '599',
        saturn: '699',
        uranus: '799',
        neptune: '899',
        pluto: '999'
    };

    const bodiesMap = { sun, mercury, venus, earth, moon, mars, jupiter, saturn, uranus, neptune, pluto };
    const today = new Date().toISOString().split("T")[0];
    const tomorrow = new Date(Date.now() + 86400000).toISOString().split("T")[0];

    async function fetchWithTimeout(url, timeout = 8000) {
        return Promise.race([
            fetch(url),
            new Promise((_, reject) =>
                setTimeout(() => reject(new Error("Timeout NASA API")), timeout)
            )
        ]);
    }

    async function fetchBody(body, id) {
        const url =
`https://ssd.jpl.nasa.gov/api/horizons.api?format=json
&COMMAND='${id}'
&OBJ_DATA='NO'
&MAKE_EPHEM='YES'
&EPHEM_TYPE='VECTORS'
&CENTER='500@10'
&START_TIME='${today}'
&STOP_TIME='${tomorrow}'
&STEP_SIZE='1 d'`.replace(/\n/g,'');

        try {
            const res = await fetchWithTimeout(url);
            const json = await res.json();
            if (!json.result) throw new Error("Risposta NASA non valida");

            const lines = json.result.split("\n");
			const KM = 1000;
			
			//parse x,y,z
            const vectorLinePos = lines.find(l => l.includes("X ="));//spazio dopo 
            if (!vectorLinePos) throw new Error("Dati vettoriali (posizione x,y,z) non trovati");
            const valuesPos = vectorLinePos.match(/-?\d+\.\d+E[+-]\d+/g);
            
			let tmp = parseFloat(valuesPos[0]) * KM;
			if (isFinite(tmp)) body.x = tmp;
			
			tmp = parseFloat(valuesPos[1]) * KM;
			if (isFinite(tmp)) body.y = tmp;
			
			tmp = parseFloat(valuesPos[2]) * KM;
			if (isFinite(tmp)) body.z = tmp;
			
			//parse vx,vy,vz
			const vectorLineVel = lines.find(l => l.includes("VX="));//tutto attaccato!
            if (!vectorLineVel) throw new Error("Dati vettoriali (velocita vx,vy,vz) non trovati");

            const valuesVel = vectorLineVel.match(/-?\d+\.\d+E[+-]\d+/g);
			
			tmp = parseFloat(valuesVel[0]) * KM;
			if (isFinite(tmp)) body.vx = tmp;
			
			tmp = parseFloat(valuesVel[1]) * KM;
			if (isFinite(tmp)) body.vy = tmp;
			
			tmp = parseFloat(valuesVel[2]) * KM;
            if (isFinite(tmp)) body.vz = tmp;

            console.log(body.name + " inizializzato con successo");
			body.status = 'ok'
        } catch (err) {
            console.warn(`Errore init ${body.name}:`, err);
			body.status = 'ko';
        }
    }

    document.body.style.cursor = "wait";

    for (let key of Object.keys(bodiesMap)) {
        await fetchBody(bodiesMap[key], ids[key]);
    }

    document.body.style.cursor = "default";
	let errors = '';
	bodies.forEach(item => { if(item.status==='ko') errors += item.name +' ';});
    alert("Sistema solare inizializzato con i dati NASA" + (errors ? ' (in errore: '+errors+')' : ''));
}




initSolarSystemFromNASA()
    .catch(() => {})

    .finally(() => {
        fixCenterOfMass(bodies);
        animate();
});
</script>
</body>
</html>
